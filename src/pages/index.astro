---
import Layout from "../layouts/Layout.astro";
import Header from "../components/Header.astro";
import {getCollection} from "astro:content";
import Post from "../components/Post.astro";
import "@fontsource/pacifico";

const posts = await getCollection('posts', (post) =>
    import.meta.env.PROD ? !post.data.draft : true
);
posts.sort((a, b) => b.data.date - a.data.date);
---

<Layout title="Notes of Matthias">
  <Header sticky={true} showReplay={true}/>
  <section
    id="hero"
    class="fixed inset-0 z-50 flex flex-col items-center justify-center hero-bg transition-transform duration-[600ms] ease-in-out"
    data-state="loading"
    aria-label="Hi there, I am Matthias"
  >
    <canvas id="particles-canvas" class="absolute inset-0 w-full h-full z-0" aria-hidden="true"></canvas>
    <div id="hero-content" class="flex flex-col items-center gap-8 p-4 relative z-10" style="transform: translateY(-220px);">
      <img
        id="profile-img"
        src="/me.jpg"
        alt="Matthias"
        class="w-32 h-32 md:w-40 md:h-40 rounded-full object-cover profile-glow hero-image"
      />
    </div>

    <button
      id="enter-btn"
      class="absolute bottom-12 p-2 rounded-full bg-transparent border-none cursor-pointer enter-btn hover:text-white hover:bg-white/10 focus:outline-2 focus:outline-white focus:outline-offset-4 transition-colors duration-300"
      aria-label="Enter site"
    >
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <defs>
          <linearGradient id="arrow-progress" x1="0" y1="5" x2="0" y2="19" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="white" />
            <stop id="progress-stop" offset="0%" stop-color="white" />
            <stop offset="0%" stop-color="currentColor" />
            <stop offset="100%" stop-color="currentColor" />
          </linearGradient>
        </defs>
        <path d="M12 5v14M5 12l7 7 7-7" stroke="url(#arrow-progress)"/>
      </svg>
    </button>
  </section>

  <main id="main-content" class="min-h-screen focus:outline-none hidden" tabindex="-1">
    <div class="mx-auto pt-36 max-w-3xl prose-xl p-4 border-b pb-12">
      <p class="text-2xl">
        Hi there, my name is Matthias, welcome to my notes. I am
        a software developer based in northern Germany.
      </p>
      <p class="text-2xl mt-2">Have fun!</p>
    </div>
    <div class="mx-auto max-w-3xl prose p-4">
      {posts.map((post) => <Post post={post} />)}
    </div>
  </main>
</Layout>

<script>
  import { createParticleLifeSystem } from '../lib/particle-life';

  const hero = document.getElementById('hero');
  const enterBtn = document.getElementById('enter-btn');
  const mainContent = document.getElementById('main-content');
  const particlesCanvas = document.getElementById('particles-canvas') as HTMLCanvasElement | null;
  const progressStop = document.getElementById('progress-stop') as SVGStopElement | null;

  if (hero && enterBtn && mainContent && particlesCanvas && progressStop) {
    const particleSystem = createParticleLifeSystem(particlesCanvas);
    let canReveal = true;
    let progressRafId: number | null = null;
    const hasSeenIntro = localStorage.getItem('hasSeenIntro') === 'true';

    const setState = (state: 'loading' | 'ready' | 'revealing' | 'hidden') => {
      hero.dataset.state = state;
    };

    const updateProgress = (now: DOMHighResTimeStamp) => {
      if (!particleSystem || hero.dataset.state === 'revealing') return;

      const progress = particleSystem.getProgress(now);
      progressStop.setAttribute('offset', `${progress * 100}%`);

      // When complete, mark as ready and stop progress updates
      if (particleSystem.isReady(now) && hero.dataset.state !== 'ready') {
        setState('ready');
        // Stop the progress animation loop since we're done
        if (progressRafId !== null) {
          cancelAnimationFrame(progressRafId);
          progressRafId = null;
        }
        return;
      }

      progressRafId = requestAnimationFrame(updateProgress);
    };

    const reveal = () => {
      setState('revealing');
      if (progressRafId !== null) {
        cancelAnimationFrame(progressRafId);
        progressRafId = null;
      }
      particleSystem?.stop();
      localStorage.setItem('hasSeenIntro', 'true');

      hero.addEventListener('transitionend', () => {
        hero.classList.add('hidden');
        mainContent.classList.remove('hidden');
        mainContent.focus();
        cleanup();
      }, { once: true });
    };

    const startHero = () => {
      setState('loading');
      hero.classList.remove('hidden');
      mainContent.classList.add('hidden');

      // Always start the particle system
      particleSystem?.start();

      if (hasSeenIntro) {
        // Skip animation, go straight to ready state
        progressStop.setAttribute('offset', '100%');
        setState('ready');
      } else {
        progressStop.setAttribute('offset', '0%');
        if (progressRafId !== null) {
          cancelAnimationFrame(progressRafId);
        }
        updateProgress();
      }
    };

    // Initialize on font load
    document.fonts.ready.then(startHero);

    // Event handlers
    const onWheel = (e: WheelEvent) => { if (e.deltaY > 0) reveal(); };
    const onKey = (e: KeyboardEvent) => { if (['ArrowDown', 'PageDown', ' '].includes(e.key)) reveal(); };
    let touchY = 0;
    const onTouchStart = (e: TouchEvent) => { touchY = e.touches[0].clientY; };
    const onTouchEnd = (e: TouchEvent) => { if (touchY - e.changedTouches[0].clientY > 50) reveal(); };
    const onResize = () => particleSystem?.resize();

    enterBtn.addEventListener('click', reveal);
    window.addEventListener('wheel', onWheel, { passive: true });
    window.addEventListener('keydown', onKey);
    window.addEventListener('touchstart', onTouchStart, { passive: true });
    window.addEventListener('touchend', onTouchEnd, { passive: true });
    window.addEventListener('resize', onResize);

    const cleanup = () => {
      window.removeEventListener('wheel', onWheel);
      window.removeEventListener('keydown', onKey);
      window.removeEventListener('touchstart', onTouchStart);
      window.removeEventListener('touchend', onTouchEnd);
      window.removeEventListener('resize', onResize);
      if (progressRafId !== null) {
        cancelAnimationFrame(progressRafId);
        progressRafId = null;
      }
    };

    // Handle replay button
    const replayBtn = document.getElementById('replay-particles-btn');
    replayBtn?.addEventListener('click', startHero);
  }
</script>

<style>
  .hero-bg {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
  }

  .profile-glow {
    box-shadow: 0 0 60px rgba(124, 58, 237, 0.3);
  }

  /* Hero states */
  #hero[data-state="revealing"] {
    transform: translateY(-100%);
  }

  /* Image fades out after 3 seconds */
  .hero-image {
    animation: fadeOut 1s ease-out 3s forwards;
  }

  @keyframes fadeOut {
    to { opacity: 0; }
  }

  /* Button states based on hero state */
  #hero[data-state="loading"] .enter-btn,
  #hero[data-state="ready"] .enter-btn {
    color: rgba(255, 255, 255, 0.2);
  }

  #hero[data-state="ready"] .enter-btn {
    color: white;
    animation: bounce 1.5s ease-in-out 0.5s infinite;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(10px); }
  }

  @media (max-width: 768px) {
    #hero-content {
      transform: translateY(-180px) !important;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .hero-image { animation: none; opacity: 1; }
    #hero[data-state="ready"] .enter-btn { animation: none; }
    #hero { transition: none; }
  }
</style>
